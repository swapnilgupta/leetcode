package graph.bfs;

import java.util.*;

public class MalwareInjection {

	static class UnionFind {

		public int[] parent, size;

		UnionFind(int n) {
			parent = new int[n];
			size = new int[n];
			for (int i = 0; i < n; i++) {
				parent[i] = i;
				size[i] = 1;
			}
		}

		public int find(int u) {
			return u != parent[u] ? parent[u] = find(parent[u]) : u;
		}

		public void union(int u, int v) {
			int pu = find(u), pv = find(v);
			if (pu != pv) {
				if (size[pu] < size[pv]) {
					parent[pu] = pv;
					size[pv] += size[pu];
				} else {
					parent[pv] = pu;
					size[pu] += size[pv];
				}
			}
		}
	}

	public static int getNodeToRemove(int gNodes, List<Integer> gFrom, List<Integer> gTo,
		List<Integer> malware) {
		// Step 1: Convert gFrom and gTo into an adjacency matrix (graph[][])
		int[][] graph = new int[gNodes][gNodes];
		for (int i = 0; i < gFrom.size(); ++i) {
			int u = gFrom.get(i) - 1;
			int v = gTo.get(i) - 1;
			graph[u][v] = 1;
			graph[v][u] = 1;
		}

		// Step 2: Convert the malware list into the initial array
		List<Integer> initialList = new ArrayList<>();
		for (int i = 0; i < malware.size(); i++) {
			if (malware.get(i) == 1) {
				initialList.add(i);
			}
		}
		int[] initial = initialList.stream().mapToInt(Integer::intValue).toArray();

		// Step 3: Use the union-find approach from the provided logic
		return minMalwareSpread(graph, initial);
	}

	public static int minMalwareSpread(int[][] graph, int[] initial) {
		int n = graph.length;

		UnionFind uf = new UnionFind(n);
		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
				if (graph[i][j] == 1) {
					uf.union(i, j);
				}
			}
		}


		int[] count = new int[n];
		for(int node : initial) {
			count[uf.find(node)]++;
		}

		int ans = -1, ansSize = -1;

		for(int node : initial) {
			int root = uf.find(node);
			if(count[root] == 1) {
				int rootSize = uf.size[root];
				if(rootSize > ansSize || (rootSize == ansSize && node < ans)) {
					ans = node;
					ansSize = rootSize;
				}
			}
		}

		return ans + 1; // Return 1-based index as expected in the problem
	}

	public static void main(String[] args) {
		// Example test case
		int gNodes = 9;
		List<Integer> gFrom = Arrays.asList(1, 2, 4, 6, 7);
		List<Integer> gTo = Arrays.asList(2, 3, 5, 7, 8);
		List<Integer> malware = Arrays.asList(0, 0, 1, 0, 1, 0, 0, 0, 0);

		int result = getNodeToRemove(gNodes, gFrom, gTo, malware);
		System.out.println("Node to remove: " + result);
	}
}
